<<<<<<< HEAD
---
title: 树形DP
date: 2023-7-28 10:52:01
tags: 
    - 算法
    - DP
    - 数据结构
description: |
    整个集训~~唯一~~最大的收获，学习了树形DP，主要思路就是从下往上合并，有种归并排序的味道。
    感觉对树状的数据结构也有了更好的了解。[例题](https://www.luogu.com.cn/problem/P1352)
---

# 树形DP！

树形DP，顾名思义就是在树上进行DP，根据存在即合理的思考，说明这种DP，一定是**依赖一棵树**的 ~~虽然过程错误但为什么结果那么合理啊喂~~。

比如说上面的[例题](https://www.luogu.com.cn/problem/P1352)，$a\_{i}$ 的选择，取决于其直接上司。那么我们不妨建一棵树，根据其关系，我们可以得出例题中的树关系

![树](./images/unflocing_pic/tree_DP_tree_1.png)

这是一颗树，可以看出依赖关系。我们设 $ f[i][0/1] $ 为 第 $i$ 个点取与不取分别的最大总收益。那么我们可以列出转移方程：

$ f[i][1] = max(f[son[i]][0],) + a[i]$
$ f[i][0] = max(f[son[i]][0/1] $

其中，$son[i]$ 为 $i$ 所有的儿子。$a[i]$ 为边权

由于数据较小，空间也大，考虑用vector代替链式前向星，代码会更简洁。

给出dp代码：

```cpp
void dp(int x)
{
    f[x][0] = 0;
    f[x][1] = a[x];
    for(int i=0 ; i<son[x].size() ; i++)
    {
        int y = son[x][i];
        dp(y);
        f[x][0] += max(f[y][0] , f[y][1]);
        f[x][1] += f[y][0];
    }
}
```

## 普通的过渡句！

__现在你已经知道树上DP了，那么，你一定会树状……线性DP动态DP背包DP区间DP数位DP计数D……__

所以，理论来讲，不考虑时间复杂度，我们可以直接进行树上的各种DP，于是就有了……

#树上背包！

__滴滴，嘀嘀嘀——滋滋——听得到吗……__

__这里是[有限电视网](https://www.luogu.com.cn/problem/P1273)__

嗯，这道题，我们考虑将 $f[i][j]$ 为 i 个节点，播到 j 个用户的最大收益（当然最小代价也一样），然后类似于背包，不考虑树，先写出转移方程再说，然后再将依赖的背包转化为树上的条件，必选转化为儿子。

注意到一个性质，f[x][j+k] ，可以被表达为，在**未连上这条边时**，$f[x][j]+f[son[x][i][k]+mp[x][y]$ 的最小值，因为在那之前就有j个点，然后再连一个k，就有j+k了。

实际实现的时候，我们用t[j]暂存加边之前的f[x][j]，因为在后续修改中，我们__**无法保证后面的一些值未被修改**__，反正存了不亏，这道题复杂度卡的不死。

那么得出转移方程：

$ f[x][j+k] = max\_{j<=size[x] & k<=size[y]}(f[x][j+k] , f[y][k] + mp[x][[y] + t[j]) $

给出DP代码：
```cpp
void dp(int x)
{
    for(int i=0 ; i<son[x].size() ; i++)
    {
        int y = son[x][i];
        dp(y);
        F(j,0,siz[x])t[j]=f[x][j];
        F(j,0,siz[x]){
            F(k,0,siz[y]){
                f[x][j+k] = max(f[x][j+k] , t[j] + f[y][k] - mp[x][y]);
            }
        }
        siz[x] += siz[y];
    }
}
```
最后找一找最大的i，使得f[1][i]>=0即可：）

## ~~光速~~QA

Q1：怎么建树？

A1：可以用前向星，用开个结构体edge，类似链表。也可以用vector模拟，但注意内存较高，最好开始定个内存；vector < vector<int> > son( n , vector<int>(m,0)); 定义n维m长数组。

Q2：转移方程怎么写？

A2：根据转移关系，先想不在树上的情况，	再加入链状情况。如背包，物品数就是子树的size之类的。
=======
---
title: 树形DP
date: 2023-7-28 10:52:01
tags: 
    - 算法
    - DP
    - 数据结构
description: |
    整个集训~~唯一~~最大的收获，学习了树形DP，主要思路就是从下往上合并，有种归并排序的味道。
    感觉对树状的数据结构也有了更好的了解。[例题](https://www.luogu.com.cn/problem/P1352)
---

# 树形DP！

树形DP，顾名思义就是在树上进行DP，根据存在即合理的思考，说明这种DP，一定是**依赖一棵树**的 ~~虽然过程错误但为什么结果那么合理啊喂~~。

比如说上面的[例题](https://www.luogu.com.cn/problem/P1352)，$a\_{i}$ 的选择，取决于其直接上司。那么我们不妨建一棵树，根据其关系，我们可以得出例题中的树关系

![树](./images/unflocing_pic/tree_DP_tree_1.png)

这是一颗树，可以看出依赖关系。我们设 $ f[i][0/1] $ 为 第 $i$ 个点取与不取分别的最大总收益。那么我们可以列出转移方程：

$ f[i][1] = max(f[son[i]][0],) + a[i]$
$ f[i][0] = max(f[son[i]][0/1] $

其中，$son[i]$ 为 $i$ 所有的儿子。$a[i]$ 为边权

由于数据较小，空间也大，考虑用vector代替链式前向星，代码会更简洁。

给出dp代码：

```cpp
void dp(int x)
{
    f[x][0] = 0;
    f[x][1] = a[x];
    for(int i=0 ; i<son[x].size() ; i++)
    {
        int y = son[x][i];
        dp(y);
        f[x][0] += max(f[y][0] , f[y][1]);
        f[x][1] += f[y][0];
    }
}
```

## 普通的过渡句！

__现在你已经知道树上DP了，那么，你一定会树状……线性DP动态DP背包DP区间DP数位DP计数D……__

所以，理论来讲，不考虑时间复杂度，我们可以直接进行树上的各种DP，于是就有了……

#树上背包！

__滴滴，嘀嘀嘀——滋滋——听得到吗……__

__这里是[有限电视网](https://www.luogu.com.cn/problem/P1273)__

嗯，这道题，我们考虑将 $f[i][j]$ 为 i 个节点，播到 j 个用户的最大收益（当然最小代价也一样），然后类似于背包，不考虑树，先写出转移方程再说，然后再将依赖的背包转化为树上的条件，必选转化为儿子。

注意到一个性质，f[x][j+k] ，可以被表达为，在**未连上这条边时**，$f[x][j]+f[son[x][i][k]+mp[x][y]$ 的最小值，因为在那之前就有j个点，然后再连一个k，就有j+k了。

实际实现的时候，我们用t[j]暂存加边之前的f[x][j]，因为在后续修改中，我们__**无法保证后面的一些值未被修改**__，反正存了不亏，这道题复杂度卡的不死。

那么得出转移方程：

$ f[x][j+k] = max\_{j<=size[x] & k<=size[y]}(f[x][j+k] , f[y][k] + mp[x][[y] + t[j]) $

给出DP代码：
```cpp
void dp(int x)
{
    for(int i=0 ; i<son[x].size() ; i++)
    {
        int y = son[x][i];
        dp(y);
        F(j,0,siz[x])t[j]=f[x][j];
        F(j,0,siz[x]){
            F(k,0,siz[y]){
                f[x][j+k] = max(f[x][j+k] , t[j] + f[y][k] - mp[x][y]);
            }
        }
        siz[x] += siz[y];
    }
}
```
最后找一找最大的i，使得f[1][i]>=0即可：）

## ~~光速~~QA

Q1：怎么建树？

A1：可以用前向星，用开个结构体edge，类似链表。也可以用vector模拟，但注意内存较高，最好开始定个内存；vector < vector<int> > son( n , vector<int>(m,0)); 定义n维m长数组。

Q2：转移方程怎么写？

A2：根据转移关系，先想不在树上的情况，	再加入链状情况。如背包，物品数就是子树的size之类的。
>>>>>>> 503badd755eaf486171ac86855b1f4e8e476051e
