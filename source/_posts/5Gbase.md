---
title: 5G基站——单调队列加DP
date: 2023-10-04 10:01:30
tags: 
    - 算法
    - DP
    - 数据结构
description: |
    单调队列加DP的一道题目，对单调队列的理解加深了！
---
# 什么是单调队列？
单调队列，是一种可以前后操作以保持队列单调的数据结构。一般来讲，我们用单调队列来实现对一段区间的维护。

单调队列有两端，但两端并不相同。我们一般认为，**左端只能进行弹出操作**~~(除非head和end撞了)~~，右端则兼具栈和队列的性质，可以进出。

以[这道题](https://www.luogu.com.cn/record/108134892)为例，我们先对询问区间排序，然后离线处理。

## 左端操作！

对于每个询问区间$[l_{i},r_{i}]$，我们先滑动左端点至 $[l]$ ，代码大致是这样：

`while(q[hd]<l[i] and hd<=ed)  hd++;  //这一步操作要先于数字加入单调队列，在前面的有等号`

使用这个操作，我们将队列不断滑动直至达到ed或进入待求区间。__当然，删去and后面的条件也问题不大，毕竟即使删去，队列还是会把hd加到l__，只是等待后面ed不断上升而已。

可以证明，无论是哪种写法，每个数字都被加入一次，弹出也最多一次，所以复杂的仍是$O(n)$

## 右端操作！

对于右端，我们通过不断弹出使得队列保持单调性。同时，由于正常人类处理数组~~（没有别的意思）~~，都是从左往右计算，~~而不是随机读写~~所以我们用右侧来处理数字进入队列。

惯用左手者可以尝试将左右反过来。

进入操作的思路大致是，在放入这个数$a_{i}$之前，把所有大于$a_{i}$的数全部从右端弹出，然后进入右端。

代码大致是这样：

`while(q[ed]>a[i] and hd<=ed)  ed--;  //实例代码可以保证单调队列从左往右递增，如果严格递增只需要变成>=`

使用这个操作，我们滑动了窗口，并获得了有效的信息。

# 单调队列DP！

在[这道题](https://www.luogu.com.cn/problem/P9691)中，我们简化题意：

给定一个长度为 $n$ 的数组 $a$ , 以及 $m$ 段区间 $[l_{i},r_{i}]$ , 求最小的 $\sum a_{j}$ , 满足对于所有 $[l_{i},r_{i}]$ , 均能找到符合的 $j$

很明显，这是个DP，我们用$f[i]$记录当i点设立基站，且前面的点都符合条件的最小值，这是最基础的DP思路。

转移方程为 ： $f[i] = min(f[j])+a[i]  ([j,i-1])$符合题意条件。这个符合条件的定义是，当i点设立基站之后，所有可能设立基站的点。

可能有点抽象，我们举个例子，如下图：



我们知道，对于每个设立基站后的点，他的前一个设立基站的点，必然在i所对应的区间的左端点$l_{p}$和上一个区间左端点$l_{p-1}$之间，我们只需要在其中寻找最小的$f[i]$即可。

当然，在具体实现中，我们可能出现推进右端点时右端点处于给定区间外的情况，但是这种情况本身在取min的时候一定会被排除，所以不用担心了。

我们可以很明显看出，我们的操作类似于在给定的m个区间内滑动窗口求所得到的最小值，**$l_{p-1}$就是窗口的左端点，单调递增。而得到的窗口应该满足从左到右，$f[i]$ 是递增的。**

那么具体实现呢？

我们用$l[i]$记录每一个点作为右端点时的左端点位置（不作为右端点时记为0），当每次右端点滑动至i时，从队头弹出所有小于$l[i]$的值。从而维护上一个点在某个范围内。

每次右端点推进时，我们将所有大于$f[i]$的队尾全部弹出。

完整的单调队列代码就是：

```cpp
#define F(a,b,c)   for(int a=b ; a<=c ; a++)
int q[1000000],f[1000000],hd=1,ed=1,a[1000000]，l[1000000]; 
// q表示队列 ， f是DP ， hd表示对头 ， ed表示队尾 ，a如题意 , l表示以i为右端点的左端点位置


F(i,1,n){
	while (f[q[ed]]>f[i] and ed>=hd) ed--; // 队尾弹出，保证递增
	q[++ed] = i;
	while (q[hd]<l[i]) hd++; // 对头弹出，保证在队列里面
}
```

其中，q[hd] 即为满足转移条件的 f[j] 最小的 j

我们就得到了新的转移方程：

`f[i] = f[q[hd]] + a[i]`

不难得出完整代码：

```cpp
void solve()
{
	cin>>n;
	F(i,1,n) cin>>a[i] , l[i]=0;//初始化不要同memset，我的数组开得很大，用memset频繁初始化用不到的位置会T
	int lt,rt;
	cin>>m;
	F(i,1,m) {
	    cin>>lt>>rt;
	    l[rt] = max(l[rt],lt); // 同一个右端点，取左端点最靠右的位置，这些区间可以被缩成一个区间。可以证明这样是最优的
	}
	int hd=1,ed=1;
	q[hd] = 0;
	a[++n] = 0;//实现的时候加一个点权为0的点，这样就可以防止由于最后一个点不应该设基站导致的问题。
    //当然也可以考虑从最后一个点向前找到前一个区间，然后枚举区间最小值的位置，最后得出答案。
	F(i,1,n){
	    f[i] = f[q[hd]] + a[i];
	    while (f[q[ed]]>f[i] and ed>=hd) ed--;
	    q[++ed] = i;
	    while (q[hd]<l[i]) hd++;
	}
	cout<<f[n]<<endl;
}

// 没有写快读优化，所以会慢一点，跑了300ms，常数不算很大，这题的限制是2s，所以应该不会T，单次操作复杂度O(n+m)

:)
```
